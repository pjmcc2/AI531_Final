import pickle
import numpy as np
from operator import itemgetter
import string
import json
from numpy.random import default_rng
import matplotlib.pyplot as plt
from tqdm import tqdm

def get_words(file):
    with open(file, "rb") as f:
        word_list = json.load(f)
    return word_list


def filter_words(words, length):
    return {w:1 for w in words.keys() if (len(w) <= length) and (len(w) > 1)}


def insert_word(array, word, position, direction):
    row, col = position
    word_length = len(word)

    if direction == "h":
        if col + word_length > len(array):
            raise ValueError("Word exceeds array bounds horizontally")
        array[row, col : col + word_length] = list(word)
    elif direction == "v":
        if row + word_length > len(array):
            raise ValueError("Word exceeds array bounds vertically")
        array[row : row + word_length, col] = list(word)
    else:
        raise ValueError("Direction must be 'horizontal' or 'vertical'")

    return array


 
def encode_list(char_string, word_dict):
    n = len(char_string)
    strings = {}

    # Step 1: Identify all substrings that are in the word dictionary
    for i in range(n):
        for j in range(i + 1, n + 1):
            substring = char_string[i:j]
            substring = "".join(substring)
            if substring in word_dict:
                strings[substring] = (i, j)

    # Step 2: Sort the substrings by their length in descending order
    sorted_strings = sorted(strings.items(), key=lambda x: len(x[0]), reverse=True)

    # Step 3: Select non-overlapping and non-adjacent valid words
    valid_words = []
    used_indices = set()

    for word, (start, end) in sorted_strings:
        # Check if the word overlaps or is adjacent to any already selected words
        if all(index not in used_indices for index in range(start, end)) and \
           all(index - 1 not in used_indices and index + 1 not in used_indices for index in range(start, end)):
            valid_words.append((word, (start, end)))
            used_indices.update(range(start, end))

    return valid_words


def encode_v2(arr,word_dict):
    encoding = []
    for i,r in enumerate(arr):
        temp = encode_list(r, word_dict)
        for w,(start,end) in temp:
            encoding.append((w,(i,start),'h'))
    for j,c in enumerate(arr.T):
        temp = encode_list(c, word_dict)
        for w,(start,end) in temp:
            encoding.append((w,(start,j),'v'))

    return encoding
    
def score_gene(gene):


    ws = 0
    ls = 0
    seen = set()
    for w,(i,j), style in gene:
        ws += 1
        if style == "h":
            for k in range(len(w)):
                if (i,j+k) not in seen:
                    seen.add((i,j+k))
                    ls += 1
        else:
            for k in range(len(w)):
                if (i+k,j) not in seen:
                    seen.add((i+k,j))
                    ls += 1
    return ws, ls

# Crossover selects randomly  (without repetition) real words from array 1 and array 2: a sample is considered
# Viable if there the corresponding location on the other array does not contain any valid words
# If no viable words are found, a random inviable word is selected.
# The new arrays are generated by overwriting whatever is at the other array's word location
def crossover(g1, g2,rng):

    rng.shuffle(g1)
    rng.shuffle(g2)
    cross1 = None
    cross2 = None
    for s in g1:
        if not check_conflict(g2, s):
            cross1 = s
            break
    if cross1 is None:
        cross1 = g1[rng.integers(0,max(1,len(g1)))]
    for s in g2:
        if not check_conflict(g1, s):
            cross2 = s
            break
    if cross2 is None:
        cross2 = g2[rng.integers(0,max(1,len(g2)))]
    g2.append(cross1)
    g1.append(cross2)

    return g1, g2


def word_positions(word, position, direction):
    row, col = position
    positions = set()

    if direction == "h":
        for i in range(len(word)):
            positions.add((row, col + i))
    elif direction == "v":
        for i in range(len(word)):
            positions.add((row + i, col))

    return positions


def check_conflict(existing_triples, new_triple):

    new_word, new_position, new_direction = new_triple
    new_positions = word_positions(new_word, new_position, new_direction)

    for word, position, direction in existing_triples:
        existing_positions = word_positions(word, position, direction)
        if new_positions & existing_positions:
            return True

    return False


# With probability M mutation occurs. mutation is performed in 3 ways, with probability p and (1-p) The primary way, with probability p assigns all
# blank cells a random letter. This encourages small (2-3) letter words to form which are common in crosswords and will increase the number of real words.
# With probablity (1-p)/2, an entirely new word will be sampled from the lexicon and randomly placed. And with prob: (1-p)/2 both previous ways happen sequentially
def mutate(array,p, dict, seed=None,rng=None):
    if rng is None:
        rng = default_rng(seed)
    sample = rng.uniform()
    if sample > p:
        return array
    sample = rng.uniform()

    word = rng.choice(list(dict.keys()),1).item()
    dir = rng.choice(["h","v"],1).item()
    pos1 = rng.integers(0,max(1,len(array)-len(word)))
    pos2 = rng.integers(0,len(array))
    if sample < 0.5:
        array = saturate(array,rng)
        return array
    if dir == "v":
        pos = (pos1,pos2)
    else:
        pos = (pos2,pos1)
    if sample > 0.5 and sample < 0.75:
        array = insert_word(array,word,pos,dir)
        return array
    else:
        array = saturate(array,rng)
        array = insert_word(array,word,pos,dir)
        return array

def reconstruct(gene,size):
    new_arr = np.zeros((size,size),dtype="object")
    for i in range(len(new_arr)):
        for j in range(len(new_arr)):
            new_arr[i,j] = "%"
    for w,pos,style in gene:
        new_arr = insert_word(new_arr,w,pos,style)
    return new_arr

def saturate(array,rng):

    letters = list(string.ascii_lowercase)
    for i in range(len(array)):
        for j in range(len(array)):
            if array[(i,j)] == "%":
                array[(i,j)] = rng.choice(letters,1).item()
    return array


def evolve(pop, p, word_dict, num_gens, arr_size, rng):
    scores = []
    for i in range(num_gens):
        
        pop.sort(key=itemgetter(1,2),reverse=True)
        scores.append((pop[0][1],pop[0][2]))
        offspring = []
        child_genes = []
        for j in range(0, len(pop), 2):
            parent1 = pop[j][0]
            parent2 = pop[j + 1][0]
            child1, child2 = crossover(parent1, parent2,rng)
            offspring.append(reconstruct(child1,arr_size))
            offspring.append(reconstruct(child2,arr_size))
        if i != num_gens-1:
            for c in offspring:
                c = mutate(c,p,word_dict,rng)
                child_genes.append(encode_v2(c,word_dict))
        if i == num_gens -1:
            for o in offspring:
                child_genes.append(encode_v2(o,word_dict))
        pop = [(g,*score_gene(g)) for g in child_genes]
    return pop, scores

def gen_pop(word_dict, pop_size, crossword_size, seed=None,rng=None):
    if rng is None: 
        rng = default_rng(seed)
    pop = [np.zeros((crossword_size,crossword_size),dtype="object") for i in range(pop_size)]
    for ar in pop:
        for i in range(len(ar)):
            for j in range(len(ar)):
                ar[i,j] = "%"
        for k in range(crossword_size//2 + 1):
            ar = mutate(ar,1,word_dict,seed=seed,rng=rng)
    return pop




pop_sizes = [20] # 60
mutation_rates = [0.5] # 1
grid_sizes = [5] # 10
num_runs = 1
num_gens = 10
# 10 runs

run_results = {}
for grid_size in grid_sizes:
    unfiltered_wd = get_words(r"C:\Users\pjmcc\PycharmProjects\AI531_Final\words_dictionary.json")
    wd = filter_words(unfiltered_wd,grid_size)
    for rate in mutation_rates:
        for pop_size in pop_sizes:
            for i in tqdm(range(num_runs)):
                word_scores = []
                letter_scores = []
                for j in range(num_gens):
                    rng = default_rng(i)
                    #initial pop
                    pop_arrays = gen_pop(wd,pop_size,grid_size,rng)
                    genes = [encode_v2(p,wd) for p in pop_arrays]
                    pop = [(g,*score_gene(g)) for g in genes]
                    #evolve
                    pop,scores = evolve(pop,rate,wd,num_gens,grid_size,rng)
                    word_scores.append([s[0] for s in scores])
                    letter_scores.append([s[1] for s in scores])
                #results
                x = np.arange(20)
                avg_ws = np.mean(np.array(word_scores),axis=0)
                avg_ls = np.mean(np.array(letter_scores),axis=0)

                run_results[(pop_size,rate,grid_size)] = (avg_ws,avg_ls)
print(reconstruct(pop[0][0],5))
out_file = "GA_1_small_TEST.pickle"
with open(out_file,"wb") as file:
    pickle.dump(run_results,file)
